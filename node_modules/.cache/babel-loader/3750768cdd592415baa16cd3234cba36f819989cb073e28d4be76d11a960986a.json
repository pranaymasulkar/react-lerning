{"ast":null,"code":"import useMergedRefs from '@restart/hooks/useMergedRefs';\nimport useEventCallback from '@restart/hooks/useEventCallback';\nimport React, { useRef, useEffect, cloneElement, useState } from 'react';\nimport NoopTransition from './NoopTransition';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function useTransition(_ref) {\n  let {\n    in: inProp,\n    onTransition\n  } = _ref;\n  const ref = useRef(null);\n  const isInitialRef = useRef(true);\n  const handleTransition = useEventCallback(onTransition);\n  useEffect(() => {\n    if (!ref.current) {\n      return;\n    }\n    handleTransition({\n      in: inProp,\n      element: ref.current,\n      initial: isInitialRef.current\n    });\n  }, [inProp, handleTransition]);\n  useEffect(() => {\n    isInitialRef.current = false;\n    // this is for strict mode\n    return () => {\n      isInitialRef.current = true;\n    };\n  }, []);\n  return ref;\n}\n/**\n * Adapts an imperative transition function to a subset of the RTG `<Transition>` component API.\n *\n * ImperativeTransition does not support mounting options or `appear` at the moment, meaning\n * that it always acts like: `mountOnEnter={true} unmountOnExit={true} appear={true}`\n */\nexport default function ImperativeTransition(_ref2) {\n  let {\n    children,\n    in: inProp,\n    onExited,\n    onEntered,\n    transition\n  } = _ref2;\n  const [exited, setExited] = useState(!inProp);\n  const ref = useTransition({\n    in: !!inProp,\n    onTransition: options => {\n      const onFinish = () => {\n        if (options.in) {\n          setExited(false);\n          onEntered == null ? void 0 : onEntered(options.element, options.initial);\n        } else {\n          setExited(true);\n          onExited == null ? void 0 : onExited(options.element);\n        }\n      };\n      Promise.resolve(transition(options)).then(onFinish);\n    }\n  });\n  const combinedRef = useMergedRefs(ref, children.ref);\n  return exited && !inProp ? null : /*#__PURE__*/cloneElement(children, {\n    ref: combinedRef\n  });\n}\nexport function renderTransition(Component, runTransition, props) {\n  if (Component) {\n    return /*#__PURE__*/_jsx(Component, Object.assign({}, props));\n  }\n  if (runTransition) {\n    return /*#__PURE__*/_jsx(ImperativeTransition, Object.assign({}, props, {\n      transition: runTransition\n    }));\n  }\n  return /*#__PURE__*/_jsx(NoopTransition, Object.assign({}, props));\n}","map":{"version":3,"names":["useMergedRefs","useEventCallback","React","useRef","useEffect","cloneElement","useState","NoopTransition","jsx","_jsx","useTransition","_ref","in","inProp","onTransition","ref","isInitialRef","handleTransition","current","element","initial","ImperativeTransition","_ref2","children","onExited","onEntered","transition","exited","setExited","options","onFinish","Promise","resolve","then","combinedRef","renderTransition","Component","runTransition","props","Object","assign"],"sources":["/Users/pranaymasulkar/Desktop/My_Projects/Git Project/react-lerning/node_modules/@restart/ui/esm/ImperativeTransition.js"],"sourcesContent":["import useMergedRefs from '@restart/hooks/useMergedRefs';\nimport useEventCallback from '@restart/hooks/useEventCallback';\nimport React, { useRef, useEffect, cloneElement, useState } from 'react';\nimport NoopTransition from './NoopTransition';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function useTransition({\n  in: inProp,\n  onTransition\n}) {\n  const ref = useRef(null);\n  const isInitialRef = useRef(true);\n  const handleTransition = useEventCallback(onTransition);\n  useEffect(() => {\n    if (!ref.current) {\n      return;\n    }\n    handleTransition({\n      in: inProp,\n      element: ref.current,\n      initial: isInitialRef.current\n    });\n  }, [inProp, handleTransition]);\n  useEffect(() => {\n    isInitialRef.current = false;\n    // this is for strict mode\n    return () => {\n      isInitialRef.current = true;\n    };\n  }, []);\n  return ref;\n}\n/**\n * Adapts an imperative transition function to a subset of the RTG `<Transition>` component API.\n *\n * ImperativeTransition does not support mounting options or `appear` at the moment, meaning\n * that it always acts like: `mountOnEnter={true} unmountOnExit={true} appear={true}`\n */\nexport default function ImperativeTransition({\n  children,\n  in: inProp,\n  onExited,\n  onEntered,\n  transition\n}) {\n  const [exited, setExited] = useState(!inProp);\n  const ref = useTransition({\n    in: !!inProp,\n    onTransition: options => {\n      const onFinish = () => {\n        if (options.in) {\n          setExited(false);\n          onEntered == null ? void 0 : onEntered(options.element, options.initial);\n        } else {\n          setExited(true);\n          onExited == null ? void 0 : onExited(options.element);\n        }\n      };\n      Promise.resolve(transition(options)).then(onFinish);\n    }\n  });\n  const combinedRef = useMergedRefs(ref, children.ref);\n  return exited && !inProp ? null : /*#__PURE__*/cloneElement(children, {\n    ref: combinedRef\n  });\n}\nexport function renderTransition(Component, runTransition, props) {\n  if (Component) {\n    return /*#__PURE__*/_jsx(Component, Object.assign({}, props));\n  }\n  if (runTransition) {\n    return /*#__PURE__*/_jsx(ImperativeTransition, Object.assign({}, props, {\n      transition: runTransition\n    }));\n  }\n  return /*#__PURE__*/_jsx(NoopTransition, Object.assign({}, props));\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}